generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String         @id @default(uuid()) @db.Uuid
  email          String         @unique
  password       String
  username       String         @unique
  profilePicture String?
  createdAt      DateTime       @default(now())
  artist         Artist?        @relation("UserArtist")
  comments       Comment[]
  followers      Follower[]     @relation("UserFollower")
  purchases      Purchase[]
  artLikes       ArtLike[]

  @@index([email])
  @@index([username])
  @@map("users")
}

model Artist {
  id                String          @id @default(uuid()) @db.Uuid
  userId            String          @unique @db.Uuid
  artistName        String          @unique
  isNsfw            Boolean         @default(false)
  bio               String?         @db.Text
  walletAddress     String?         @unique // For blockchain integration
  totalFollowers    Int             @default(0)
  totalArts         Int             @default(0)
  totalCollections  Int             @default(0)
  isVerified        Boolean         @default(false)
  createdAt         DateTime        @default(now())
  arts              Art[]
  collections       ArtCollection[]
  user              User            @relation("UserArtist", fields: [userId], references: [id], onDelete: Cascade)
  feed              Feed[]
  followers         Follower[]      @relation("ArtistFollower")

  @@index([artistName])
  @@index([walletAddress])
  @@index([isVerified])
  @@map("artists")
}

model Follower {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  artistId  String   @db.Uuid
  createdAt DateTime @default(now())
  artist    Artist   @relation("ArtistFollower", fields: [artistId], references: [id], onDelete: Cascade)
  user      User     @relation("UserFollower", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, artistId])
  @@index([userId])
  @@index([artistId])
  @@map("followers")
}

model Art {
  id           String            @id @default(uuid()) @db.Uuid
  imageUrl     String
  title        String
  description  String            @db.Text
  datePosted   DateTime          @default(now())
  artistId     String            @db.Uuid
  tokenId      BigInt            @unique // Blockchain token ID
  likesCount   Int               @default(0)
  isInACollection    Boolean           @default(false)
  artist       Artist            @relation(fields: [artistId], references: [id], onDelete: Cascade)
  collections  ArtToCollection[]
  tags         ArtToArtTag[]
  comments     Comment[]
  likes        ArtLike[]

  @@index([artistId])
  @@index([tokenId])
  @@index([datePosted])
  @@index([isInACollection])
  @@map("arts")
}

model ArtLike {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  artId     String   @db.Uuid
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  art       Art      @relation(fields: [artId], references: [id], onDelete: Cascade)

  @@unique([userId, artId])
  @@index([artId])
  @@map("art_likes")
}

model Comment {
  id        String   @id @default(uuid()) @db.Uuid
  content   String   @db.Text
  createdAt DateTime @default(now())
  userId    String   @db.Uuid
  artId     String   @db.Uuid
  art       Art      @relation(fields: [artId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([artId])
  @@index([userId])
  @@index([createdAt])
  @@map("comments")
}

model ArtTag {
  id       String        @id @default(uuid()) @db.Uuid
  tagName  String        @unique
  usageCount Int         @default(0)
  createdAt DateTime     @default(now())
  arts     ArtToArtTag[]

  @@index([tagName])
  @@map("art_tags")
}

model ArtCollection {
  id             String            @id @default(uuid()) @db.Uuid
  collectionName String
  description    String?           @db.Text
  coverImageUrl  String?
  price          Decimal?          @db.Decimal(18, 8) // For collection access price
  tokenId        BigInt?           @unique // Collection NFT token ID
  createdAt      DateTime          @default(now())
  artistId       String            @db.Uuid
  artist         Artist            @relation(fields: [artistId], references: [id], onDelete: Cascade)
  arts           ArtToCollection[]
  purchases      Purchase[]

  @@index([artistId])
  @@index([tokenId])
  @@map("art_collections")
}

model ArtToCollection {
  id           String        @id @default(uuid()) @db.Uuid
  artId        String        @db.Uuid
  collectionId String        @db.Uuid
  addedAt      DateTime      @default(now())
  art          Art           @relation(fields: [artId], references: [id], onDelete: Cascade)
  collection   ArtCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([artId, collectionId])
  @@index([collectionId])
  @@map("art_to_collections")
}

model Purchase {
  id           String         @id @default(uuid()) @db.Uuid
  userId       String         @db.Uuid
  collectionId String         @db.Uuid // For collection access purchases
  price        Decimal        @db.Decimal(18, 8)
  txHash       String?        @unique // Blockchain transaction hash
  status       PurchaseStatus @default(PENDING)
  createdAt    DateTime       @default(now())
  completedAt  DateTime?
  user         User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  collection   ArtCollection  @relation(fields: [collectionId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([collectionId])
  @@index([status])
  @@index([txHash])
  @@map("purchases")
}

model Feed {
  id         String   @id @default(uuid()) @db.Uuid
  artistId   String   @db.Uuid
  title      String
  content    String   @db.Text
  imageUrl   String?
  datePosted DateTime @default(now())
  artist     Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@index([artistId])
  @@index([datePosted])
  @@map("feeds")
}

model ArtToArtTag {
  artId String @db.Uuid
  tagId String @db.Uuid
  art   Art    @relation(fields: [artId], references: [id], onDelete: Cascade)
  tag   ArtTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([artId, tagId])
  @@map("art_to_art_tags")
}

// Enums
enum PurchaseStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}