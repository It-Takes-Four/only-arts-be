generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                   String         @id @default(uuid()) @db.Uuid
  email                String         @unique
  password             String
  username             String         @unique
  profilePictureFileId String?        @unique @db.Uuid
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  artLikes             ArtLike[]
  artist               Artist?        @relation("UserArtist")
  comments             Comment[]
  followers            Follower[]     @relation("UserFollower")
  notifications        Notification[]
  purchases            Purchase[]
  profilePictureFile   File?          @relation("UserProfilePicture", fields: [profilePictureFileId], references: [id])

  @@index([email])
  @@index([username])
  @@map("users")
}

model Artist {
  id               String          @id @default(uuid()) @db.Uuid
  userId           String          @unique @db.Uuid
  artistName       String          @unique
  isNsfw           Boolean         @default(false)
  bio              String?
  walletAddress    String?         @unique
  totalFollowers   Int             @default(0)
  totalArts        Int             @default(0)
  totalCollections Int             @default(0)
  isVerified       Boolean         @default(false)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  collections      ArtCollection[]
  user             User            @relation("UserArtist", fields: [userId], references: [id], onDelete: Cascade)
  arts             Art[]
  feed             Feed[]
  followers        Follower[]      @relation("ArtistFollower")
  notifications    Notification[]

  @@index([artistName])
  @@index([walletAddress])
  @@index([isVerified])
  @@map("artists")
}

model Notification {
  id        String   @id @default(uuid()) @db.Uuid
  message   String
  userId    String   @db.Uuid
  artistId  String?  @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  artist    Artist?  @relation(fields: [artistId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([artistId])
  @@map("notifications")
}

model Follower {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  artistId  String   @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  artist    Artist   @relation("ArtistFollower", fields: [artistId], references: [id], onDelete: Cascade)
  user      User     @relation("UserFollower", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, artistId])
  @@index([userId])
  @@index([artistId])
  @@map("followers")
}

model Art {
  id              String            @id @default(uuid()) @db.Uuid
  imageFileId     String            @unique @db.Uuid
  title           String
  description     String
  datePosted      DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  artistId        String            @db.Uuid
  tokenId         BigInt            @unique
  likesCount      Int               @default(0)
  isInACollection Boolean           @default(false)
  likes           ArtLike[]
  tags            ArtToArtTag[]
  collections     ArtToCollection[]
  artist          Artist            @relation(fields: [artistId], references: [id], onDelete: Cascade)
  imageFile       File              @relation("ArtImageFile", fields: [imageFileId], references: [id])
  comments        Comment[]

  @@index([artistId])
  @@index([tokenId])
  @@index([datePosted])
  @@index([isInACollection])
  @@index([imageFileId])
  @@map("arts")
}

model ArtLike {
  id        String   @id @default(uuid()) @db.Uuid
  userId    String   @db.Uuid
  artId     String   @db.Uuid
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  art       Art      @relation(fields: [artId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, artId])
  @@index([artId])
  @@map("art_likes")
}

model Comment {
  id        String   @id @default(uuid()) @db.Uuid
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String   @db.Uuid
  artId     String   @db.Uuid
  art       Art      @relation(fields: [artId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([artId])
  @@index([userId])
  @@index([createdAt])
  @@map("comments")
}

model ArtTag {
  id         String        @id @default(uuid()) @db.Uuid
  tagName    String        @unique
  usageCount Int           @default(0)
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  arts       ArtToArtTag[]

  @@index([tagName])
  @@map("art_tags")
}

model ArtCollection {
  id               String            @id @default(uuid()) @db.Uuid
  collectionName   String
  description      String?
  coverImageFileId String?           @unique @db.Uuid
  price            Decimal?          @db.Decimal(18, 8)
  tokenId          BigInt?           @unique
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  artistId         String            @db.Uuid
  artist           Artist            @relation(fields: [artistId], references: [id], onDelete: Cascade)
  coverImageFile   File?             @relation("CollectionCoverImage", fields: [coverImageFileId], references: [id])
  arts             ArtToCollection[]
  purchases        Purchase[]

  @@index([artistId])
  @@index([tokenId])
  @@index([coverImageFileId])
  @@map("art_collections")
}

model ArtToCollection {
  id           String        @id @default(uuid()) @db.Uuid
  artId        String        @db.Uuid
  collectionId String        @db.Uuid
  addedAt      DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  art          Art           @relation(fields: [artId], references: [id], onDelete: Cascade)
  collection   ArtCollection @relation(fields: [collectionId], references: [id], onDelete: Cascade)

  @@unique([artId, collectionId])
  @@index([collectionId])
  @@map("art_to_collections")
}

model Purchase {
  id           String         @id @default(uuid()) @db.Uuid
  userId       String         @db.Uuid
  collectionId String         @db.Uuid
  price        Decimal        @db.Decimal(18, 8)
  txHash       String?        @unique
  status       PurchaseStatus @default(PENDING)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt
  completedAt  DateTime?
  collection   ArtCollection  @relation(fields: [collectionId], references: [id])
  user         User           @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([collectionId])
  @@index([status])
  @@index([txHash])
  @@map("purchases")
}

model Feed {
  id         String   @id @default(uuid()) @db.Uuid
  artistId   String   @db.Uuid
  title      String
  content    String
  imageUrl   String?
  datePosted DateTime @default(now())
  updatedAt  DateTime @updatedAt
  artist     Artist   @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@index([artistId])
  @@index([datePosted])
  @@map("feeds")
}

model ArtToArtTag {
  artId String @db.Uuid
  tagId String @db.Uuid
  art   Art    @relation(fields: [artId], references: [id], onDelete: Cascade)
  tag   ArtTag @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([artId, tagId])
  @@map("art_to_art_tags")
}

model File {
  id              String         @id @default(uuid()) @db.Uuid
  fileName        String
  originalName    String
  mimetype        String
  size            Int
  createdAt       DateTime       @default(now())
  collectionCover ArtCollection? @relation("CollectionCoverImage")
  artImage        Art?           @relation("ArtImageFile")
  userProfile     User?          @relation("UserProfilePicture")

  @@map("files")
}

enum PurchaseStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}
